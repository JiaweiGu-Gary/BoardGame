# 测试与审计规范

> 本文档定义测试策略、审计工具使用和质量保证流程。**触发条件**：新增功能/技能/API、修复 bug、审查实现完整性时阅读。

---

## 测试策略总览

**GameTestRunner 行为测试是最优先、最可靠的测试手段**，审计工具是补充。

| 工具 | 适用场景 |
|------|---------|
| GameTestRunner | 命令序列+状态断言（首选） |
| entityIntegritySuite | 数据定义契约（注册表/引用链/触发路径/效果/i18n） |
| referenceValidator | 实体引用链提取与验证 |
| interactionChainAudit | UI 状态机 payload 覆盖（模式 A） |
| interactionCompletenessAudit | Interaction handler 注册覆盖（模式 B） |

**新游戏选型**：所有游戏必选 GameTestRunner；≥20 实体 → entityIntegritySuite；有多步 UI 交互 → interactionChainAudit；有 InteractionSystem → interactionCompletenessAudit。

---

## 效果数据契约测试（强制）

> 新增游戏/英雄/卡牌/Token 定义时，必须同步编写契约测试。

**契约测试的职责**：
1. **结构完整性**：字段存在、引用不断裂、格式正确
2. **语义正确性**：目标合法性、数值范围、枚举值合法性

**数据结构完整性原则（强制）**：
- 数据定义必须包含所有执行所需的字段，禁止在执行层"猜测"缺失信息
- 契约测试必须检查数据语义正确性，不只是字段存在性

### `createEffectContractSuite<TSource, TEffect>` 工厂

接受 `getSources()` / `getSourceId()` / `extractEffects()` / `rules: EffectContractRule[]` / `minSourceCount`。

每条 `EffectContractRule` 定义：`name` / `appliesTo(effect)` / `check(effect)` / `describeViolation(effect)`。

### `createI18nContractSuite<TSource>` 工厂

验证 i18n key 格式（正则）和存在性（各语言文件）。接受 `keyExtractors` + `locales`。

### 强制要求

- 新增实体 → 确保现有契约规则覆盖，运行测试
- 新增效果类型 → 评估是否需新增契约规则
- 新增游戏 → 创建 `entity-chain-integrity.test.ts` 并注册契约规则
- 所有有 action 的效果必须声明 timing

---

## 交互链完整性审计 — 模式 A：UI 状态机（强制）

> 多步交互（UI ≥2 步输入构建 payload）必须声明 `interactionChain`。

### 核心类型（`engine/primitives/ability.ts`）

```typescript
interface InteractionStep { step: string; inputType: 'unit'|'position'|'card'|'direction'|'choice'|'cards'; producesField: string; optional?: boolean; }
interface PayloadContract { required: string[]; optional?: string[]; }
interface InteractionChain { steps: InteractionStep[]; payloadContract: PayloadContract; }
```

### 三类检查

| 检查 | 检测的 bug |
|------|-----------|
| 声明完整性：多步技能是否都声明了 `interactionChain` | 新增多步技能忘记声明 |
| 步骤覆盖：steps 产出 ⊇ payloadContract.required | UI 缺少某个交互步骤 |
| 契约对齐：定义层与执行器的 payloadContract 双向一致 | 两端字段不同步 |

---

## 交互完整性审计 — 模式 B：Interaction 链（强制）

> 使用 InteractionSystem 的游戏必须创建此审计。

### 三类检查

| 检查 | 检测的 bug |
|------|-----------|
| Handler 注册覆盖：所有 sourceId 都有对应 handler | 创建了交互但没注册处理函数 |
| 链式完整性：handler 产出的后续 sourceId 也有 handler | 多步链中间断裂 |
| 孤儿 Handler：注册了 handler 但无能力引用 | 死代码/重构遗留 |

### 审计输入自动抽取（P0 强制）

禁止长期维护超长手工列表。审计输入应从源码自动抽取（静态分析 `createSimpleChoice`/`registerInteractionHandler` 调用）。动态 `sourceId`（非字面量）视为审计风险，必须改成可静态分析或补充白名单。

**模式 A vs B**：A 检查 UI payload 字段覆盖，B 检查 handler 注册覆盖。一个游戏可同时使用两种。

---

## CI 质量门禁（P0）

PR 必跑并阻断合并：`typecheck` → `test:games` → `i18n:check` → `test:e2e:critical`。

---

## 通用实现缺陷检查维度（强制）

> **所有审查/审计/新增功能验证时，必须按以下维度逐项检查**。这是穷举式的通用框架，不再依赖"遇到一个加一个"的反模式清单。每个维度下的具体检查项适用于所有游戏、所有实体类型。

### 维度总览

| # | 维度 | 核心问题 | 典型缺陷 |
|---|------|---------|----------|
| D1 | 语义保真 | 实现是否忠实于权威描述？ | 多做/少做/做错 |
| D2 | 边界完整 | 所有限定条件是否全程约束？ | 过滤条件缺失/多余/位置错误 |
| D3 | 数据流闭环 | 定义→注册→执行→状态→UI→测试 是否闭环？ | 某层断裂/跳过 |
| D4 | 查询一致性 | 可被动态修改的属性是否走统一入口？ | 直接读底层字段绕过 buff/光环 |
| D5 | 交互完整 | 玩家决策点是否都有对应 UI？ | "可以/may" 被自动执行 |
| D6 | 副作用传播 | 新增效果是否触发已有机制的连锁？ | 伤害未触发防御/死亡未触发遗言 |
| D7 | 资源守恒 | 代价/消耗/限制是否正确扣除和恢复？ | 免费使用/重复扣费/回合结束未清理 |
| D8 | 时序正确 | 效果的触发顺序和生命周期是否正确？ | 先结算后触发/持续效果提前消失/延迟效果未触发 |
| D9 | 幂等与重入 | 重复触发/撤销重做是否安全？ | 叠加失控/撤销后状态残留 |
| D10 | 元数据一致 | 声明的 categories/tags/meta 是否与实际行为匹配？ | 下游分支判断被跳过 |

### D1 语义保真

**检查方法**：将权威描述拆为原子语句，逐句与实现代码对照。

| 检查项 | 怎么查 |
|--------|--------|
| 少做：描述中有但实现中没有的效果 | 原子语句 vs 执行代码逐句对照 |
| 多做：实现中有但描述中没有的效果 | 执行代码中每个 side-effect 回溯到描述依据 |
| 做错：效果存在但语义不一致 | 数值/目标/条件/时机逐项比对 |
| 描述歧义：同一句话可有多种理解 | 标记并向用户确认，禁止自行选择 |

### D2 边界完整

**检查方法**：提取描述中所有限定词（名词修饰语、数值范围、距离、阵营、类型），追踪每个限定词在定义层→验证层→执行层→UI层是否全程约束。

| 检查项 | 怎么查 |
|--------|--------|
| 目标过滤缺失 | 描述说"友方士兵"，实现是否过滤了敌方/冠军/召唤师？ |
| 目标过滤多余 | 描述说"单位"（无限定），实现是否多加了阵营/类型过滤？ |
| 距离/范围约束 | 描述说"3格内"，定义层/验证层/UI层是否三重检查？ |
| 数值边界 | 0值/最大值/溢出是否处理？ |
| 时机约束 | "攻击后"/"回合开始时"是否在正确的 trigger 点？ |
| 次数约束 | "每回合一次"/"每场一次"是否有计数器和校验？ |

### D3 数据流闭环

**检查方法**：对每个功能点，追踪完整的数据流路径。

| 层级 | 检查项 |
|------|--------|
| 定义层 | 效果/能力是否在数据定义中声明？字段值是否与描述一致？ |
| 注册层 | 定义是否注册到对应 registry？白名单/映射表是否同步？ |
| 执行层 | 触发/执行逻辑是否存在？是否被正确调用？ |
| 状态层 | 事件是否被 reduce 正确持久化？所有代价是否有对应 reduce？ |
| 验证层 | 新增效果是否影响其他命令的合法性判定？ |
| UI层 | 视觉反馈/交互入口/状态提示是否同步？ |
| i18n层 | 所有面向玩家的文本是否在全部语言文件中有对应条目？ |
| 测试层 | 是否有端到端测试覆盖"触发→生效→状态正确"？ |

**断裂检测**：grep 实体 ID，若只出现在定义+注册文件 → 消费层缺失。

### D4 查询一致性

**检查方法**：识别所有可被动态修改的属性，grep 原始字段访问，逐个判定。

| 检查项 | 怎么查 |
|--------|--------|
| 直接读底层字段用于计算/判定 | grep `.card.abilities`、`.strength`、`.life` 等原始字段 |
| UI 层直接读底层字段显示数值 | grep `.tsx` 文件中的原始字段访问 |
| 检查其他实体属性时绕过统一入口 | 交叉实体查询是否也走统一函数？ |

**判定标准**：该查询结果是否会因 buff/光环/共享/临时效果而改变？→ 是 → 必须走统一入口。只关心"印刷值"？→ 可以直接访问。

### D5 交互完整

**检查方法**：提取描述中所有决策点，逐个确认 UI 实现。

| 检查项 | 怎么查 |
|--------|--------|
| "可以/may" → 确认+跳过 UI | 是否有取消/跳过按钮？是否被自动执行？ |
| "选择/指定" → 目标选择 UI | 是否有高亮+点击交互？选择范围是否与描述一致？ |
| "代替 X 做 Y" → 两个原子操作 | X 的资源/机会是否被消耗？Y 的效果是否正确执行？ |
| 多步交互 → 交互链声明 | 是否声明了 `interactionChain`？steps 是否覆盖所有输入？ |
| 条件不满足时 → 拒绝/灰显 | 按钮是否正确禁用？错误提示是否清晰？ |

### D6 副作用传播

**检查方法**：列出新增效果可能触发的已有机制，逐个确认。

| 检查项 | 怎么查 |
|--------|--------|
| 伤害 → 是否触发防御/护甲/免疫/反击？ | 追踪 DAMAGE_DEALT 事件的所有消费者 |
| 死亡 → 是否触发遗言/死亡奖励/连锁？ | 追踪 UNIT_DESTROYED 事件的所有消费者 |
| 移动 → 是否触发陷阱/光环进出/区域效果？ | 追踪 UNIT_MOVED 事件的所有消费者 |
| 状态变更 → 是否触发监听该状态的被动？ | grep 状态字段的所有读取点 |
| 新增事件类型 → 已有的 "onAffected" 类聚合是否覆盖？ | 检查聚合抽象的事件列表 |

### D7 资源守恒

**检查方法**：追踪所有资源/代价/限制的增减。

| 检查项 | 怎么查 |
|--------|--------|
| 代价是否正确扣除 | 使用技能/打出卡牌时，魔力/行动点/攻击次数是否减少？ |
| 代价是否重复扣除 | 撤销重做/重试时是否多扣？ |
| 临时效果回合结束是否清理 | `extraAttacks`/`tempAbilities`/buff 是否在正确时机清零？ |
| 限制是否正确恢复 | `hasAttacked`/`hasMoved` 是否在新回合重置？ |
| 免费使用 | "代替攻击"是否消耗了攻击行动？"免费"是否真的不扣费？ |

### D8 时序正确

**检查方法**：画出效果的生命周期时间线，与实现对照。

| 检查项 | 怎么查 |
|--------|--------|
| 触发时机 | "攻击后" vs "攻击时" vs "攻击前" 是否在正确的 hook 点？ |
| 持续时间 | "本回合"/"下个回合开始时"/"直到被消灭" 是否正确 tick？ |
| 结算顺序 | 多个同时触发的效果，优先级是否正确？ |
| 延迟效果 | "下个回合开始时"是否有定时器/phase hook？ |
| 即时 vs 持续 | 一次性效果是否误做成持续？持续效果是否误做成一次性？ |

### D9 幂等与重入

**检查方法**：模拟重复触发和撤销场景。

| 检查项 | 怎么查 |
|--------|--------|
| 重复触发 | 同一事件触发两次，效果是否叠加？应该叠加吗？ |
| 撤销后状态 | Undo 后临时状态（buff/extraAttacks）是否正确回退？ |
| 刷新后重播 | EventStream 消费者是否跳过历史事件？ |
| 并发安全 | 多个玩家同时操作是否产生竞态？ |

### D10 元数据一致

**检查方法**：对比声明的元数据与实际运行时行为。

| 检查项 | 怎么查 |
|--------|--------|
| categories 声明 vs 实际输出事件 | handler 产生 DAMAGE_DEALT → categories 必须包含 'damage' |
| tags 声明 vs 实际用途 | 注册的 tags 是否被 `filterByTags` 正确消费？ |
| trigger 声明 vs 实际触发点 | `trigger: 'afterAttack'` 是否真的在攻击后被调用？ |
| validation 声明 vs 实际校验 | `requiredPhase`/`costCheck` 是否被通用验证函数执行？ |

### 维度选择指南

| 任务类型 | 必选维度 | 推荐维度 |
|----------|---------|---------|
| 新增技能/效果 | D1, D2, D3, D5 | D6, D7, D8, D10 |
| 修复"没效果"bug | D4, D3, D1 | D8, D10 |
| 修复"触发了但状态没变" | D8, D3, D9 | D1, D7 |
| 修复"点了没反应" | D5, D3, D10 | D8 |
| 全面审查已有机制 | D1-D10 全选 | — |
| 新增 buff/共享机制 | D4, D1, D6 | D10 |
| 重构事件流 | D3, D8, D9 | D10, D4 |

### 输出格式

每次审查必须输出：
1. **所选维度及理由**
2. **每个维度的检查结果**（✅/❌ + 具体证据）
3. **发现的问题清单**（文件+行号+问题描述+修复方案）

---

## 教训附录（具体案例索引）

> 以下为历史积累的具体教训，按所属维度分类。遇到类似场景时可参考，但审查时应使用上方的通用维度检查，而非逐条对照此列表。

### D1/D2 相关教训

- **语义边界遗漏**：实现中添加了描述中不存在的"敌方"过滤条件，导致友方单位被错误排除
- **"代替"语义拆分不足**：描述说"代替普通攻击进行范围攻击"，实现只做了范围攻击但没消耗普通攻击机会
- **filter 条件无描述依据**：实现中的 `filter(u => u.owner !== currentPlayer)` 在描述中找不到"敌方"限定词
- **zombie_outbreak 限定条件仅入口检查**：执行时未全程约束，导致条件绕过

### D3/D8 相关教训

- **rapid_fire 事件副作用**：`ABILITY_TRIGGERED` 事件在 afterAttack 自动触发阶段被发射，reduce 中无条件递增 usageCount，导致后续手动激活时验证失败。修复：通过 `skipUsageCount` payload 字段区分自动触发和手动激活
- **通知事件产生状态变更**：本应只用于 UI 展示的通知事件，在 reduce 中意外修改了游戏状态
- **同一事件类型在不同阶段语义不同**：自动触发阶段的 `ABILITY_TRIGGERED` 是"通知 UI 显示效果"，手动激活阶段的是"记录使用次数"，但 reduce 无法区分

### D4 相关教训

- **直接读 `unit.card.abilities` 绕过 buff 系统**：应通过 `getUnitAbilities(unit, state)` 获取，否则临时能力/共享能力不生效
- **UI 层直接读底层字段**：`.tsx` 中直接读 `unit.attack` 而非通过查询函数，导致攻击力 buff 不显示在界面上

### D5 相关教训

- **"可选"效果自动执行**：描述说"你可以消耗 1 充能"，实现直接自动消耗，没有确认/跳过 UI
- **usesPerTurn 与自动触发冲突（rapid_fire）**：afterAttack 自动触发阶段递增了 usageCount，导致手动确认阶段验证拒绝。根因是 D8 的事件副作用问题，但表现为交互流程断裂

### D9 相关教训（测试↔运行时等价性）

- **测试只断言事件不断言状态**：测试检查 `events` 包含 `DAMAGE_DEALT` 就通过，但 reduce 中该事件的 handler 有 bug，实际 HP 未扣减
- **角色反转测试错误**：防御阶段测试中把"攻击者"设为发起攻击的玩家，但运行时约定防御阶段的"攻击者"是防御者
- **测试按错误理解编写**：测试断言伤害值为固定 3，但描述说"等于友方单位数量"，测试恰好在 3 个友方单位的场景下通过

### D10 相关教训

- **categories 声明缺失**：handler 产生 `DAMAGE_DEALT` 事件但 categories 未声明 `'damage'`，导致 `playerAbilityHasDamage` 判定为 false，防御投掷阶段被跳过
- **注册了 handler 但无能力引用**：重构后旧 handler 未清理，成为死代码

### 常见遗漏模式（历史案例速查）

| 案例 | 遗漏类型 | 所属维度 |
|------|---------|---------|
| wizard_scry：搜牌库后未洗牌 | 交互链拆分不完整（遗漏最后一步） | D1 |
| zombie_outbreak：限定条件仅入口检查，执行时未约束 | 条件表达式作用范围不足 | D2 |
| trample：穿越伤害未区分敌我（描述无限定词，正确） | 语义边界误判（实际是正确的） | D2 |
| rapid_fire：自动触发递增 usageCount 导致手动激活被拒 | 事件副作用 + 交互流程断裂 | D8 + D5 |

---

## 描述→实现全链路审查规范（强制）

> **当用户说"审查"/"审核"/"检查实现"/"核对"等词时，必须按此规范执行，禁止凭印象回答。**

### 适用场景

① 新增技能/效果/事件卡/被动/光环实现 ② 修复"没效果"类 bug ③ 审查已有机制 ④ 重构涉及消费链路

### 审查流程

**第零步：锁定权威描述** — 权威来源按可信度排序：① **用户在当前对话中明确给出的描述**（最高优先级）→ ② **`src/games/<gameId>/rule/*.md` 中已录入的规则文本**（经用户确认的录入产物）→ ③ **卡牌实物图片**（需辨认，看不清时必须停止并向用户确认）。**禁止将以下来源作为权威输入**：i18n JSON、AbilityDef.description、代码注释——这些是实现产物，可能已经带着错误理解。当不同来源冲突时，以用户明确给出的为准；有任何疑问时必须向用户确认后再开始。

**第一步：拆分独立交互链** — 审查的原子单位是**独立交互链**，不是"卡牌"或"技能"。任何需要独立触发条件、玩家输入、或状态变更路径的效果，都必须作为单独的审查条目。

拆分信号：
- 不同的触发时机（"打出时" vs "之后每当…时"）
- 需要玩家做出新的选择
- 独立的条件→结果对
- **"可以/可选"语义**：描述中"你可以"/"may"必须作为独立交互链，实现必须包含确认/跳过 UI，禁止自动执行
- **"代替 X 做 Y"语义**：必须拆为两个原子操作——"消耗 X 的资源/机会"和"执行 Y 的效果"

**作用目标语义边界锁定（强制）**：拆解每个原子步骤时，**作用目标（名词）的语义边界必须精确锁定**：
- **无限定词 = 不区分**："士兵"/"单位"/"卡牌" = 所有，包括敌我双方
- **有限定词 = 严格过滤**："敌方士兵"/"友方单位"/"你的卡牌" = 仅限定范围
- **禁止凭"游戏常识"或"设计直觉"自行添加描述中不存在的限定条件**
- **审查时**：对实现中每个 filter/条件表达式，回溯到权威描述确认该过滤条件有描述依据。实现中存在但描述中不存在的过滤条件 = ❌

**第一步自检（强制）**：拆分完成后，将所有交互链描述拼接，与原文逐句对照。原文中每一句话都必须被至少一条链覆盖，否则禁止进入第二步。

**第二步：逐链追踪八层**

| 层 | 检查内容 |
|----|----------|
| 1. 定义层 | 效果在数据定义中声明，字段值与权威描述一致 |
| 2. 注册层 | 定义已注册到对应 registry，白名单/映射表已同步更新 |
| 3. 执行层 | 触发/执行逻辑存在且语义一致 |
| 4. 状态层 | 状态变更被 reduce 正确持久化，所有代价都有对应 reduce。**事件副作用审计**：reduce handler 中除"持久化本事件描述的状态变更"外的任何逻辑（如递增计数器、修改无关字段）都是副作用嫌疑，必须逐个确认合理性。同一事件类型在不同阶段（自动触发 vs 手动激活）是否需要不同处理？ |
| 5. 验证层 | 是否影响其他命令合法性。**两阶段验证冲突检查**：自动触发阶段产生的计数/状态变更是否会导致后续手动激活阶段的验证拒绝？（如 rapid_fire 的 usageCount 冲突） |
| 6. UI 层 | 视觉反馈/交互入口/状态提示同步 |
| 7. i18n 层 | 所有面向玩家的文本在全部语言文件中有对应条目 |
| 8. 测试层 | 端到端测试覆盖"触发→生效→状态正确" |

**第三步：grep 发现所有消费点** — ID 只出现在定义+注册文件 = 消费层缺失。

**第四步：交叉影响检查** — 新增的交互链是否会触发已有机制的连锁反应。列出可能的连锁路径，确认已有机制能正确响应或显式声明不触发。

### 测试覆盖要求

每条交互链：正向（触发→生效→验证状态）+ 负向（不触发→状态未变）+ 边界（0值/空目标/多次叠加）。

- **事件发射 ≠ 状态生效**，必须同时断言 reduce 后的最终状态
- **"可以/可选"效果**：正向（确认→生效）+ 负向（跳过→不生效）+ 验证（条件不满足→拒绝）
- 禁止只测注册/写入就判定"已实现"

### 产出要求

- 输出"独立交互链 × 八层"矩阵，每条链附带权威描述原文
- 每个交叉点 ✅/❌ + 具体证据（文件名+函数名）
- ❌ 时立即修复或标注 TODO
- 禁止"看起来没问题"的模糊结论

---

## 数据查询一致性审查（强制）

> 纵向链路（定义→注册→执行→状态→…）完整，不代表实现完整——消费点绕过统一查询入口是最常见的"没效果"根因。

**审查方法**：

1. **识别统一查询入口**：每个可被动态修改的属性都有"正确的查询方式"（如通过函数获取而非直接读字段）。审查时必须明确列出。

2. **grep 原始字段访问**：搜索所有直接访问底层数据的代码，排除合法场景（查询函数内部、不受该机制影响的场景）后，剩余的都是绕过嫌疑。

3. **逐个判定**：该查询结果是否会因 buff/共享/临时效果而改变？→ 是 → 必须走统一入口。只关心"印刷值"？→ 可以直接访问。

4. **输出绕过清单**：文件+行号+当前代码+应改为。

**典型绕过模式**：

| 绕过模式 | 影响 |
|----------|------|
| 直接读实体的原始属性字段用于计算/判定 | buff/光环/共享/临时效果不生效 |
| 检查其他实体的属性时绕过统一入口 | 其他实体的动态效果不生效 |
| UI 层直接读底层字段显示数值 | 动态修正不反映在界面上 |

**适用时机**：新增"修改/增强/共享"类机制时、修复"没效果"类 bug 后、重构数据查询入口时。**grep 范围必须包含 `.tsx` 文件**。

---

## 元数据语义一致性审计（强制）

> 注册完整性审计只检查"是否注册了"，不检查"元数据声明是否与实际行为一致"。元数据被下游逻辑消费时，语义错误会导致静默的逻辑分支错误。

### 核心原则

**handler/执行器的元数据声明（categories/tags/meta）必须与其实际输出一致**。下游逻辑依赖元数据做分支判断时，声明缺失会导致分支被跳过。

### 审计方法

1. **自动化审计**：对每个注册的 handler 调用（mock 状态），检查输出事件类型是否与元数据声明一致
2. **反向检查**：声明了某 category 但 handler 未产生对应事件 → 声明过度或 mock 不足
3. **适用时机**：新增/修改 handler 时（强制）；修复"某阶段被跳过"/"效果未触发"类 bug 时

---

## 效果语义一致性审查（强制）

> 审计不能只检查"有没有产生正确类型的事件"，还必须检查"事件的产生方式是否与规则描述的机制一致"。测试按错误实现编写时，测试通过 ≠ 实现正确。

### 审查方法

1. **锁定权威描述**：特别关注"如何计算"的部分（数据来源、计算公式、触发条件）

2. **语义拆解**，重点关注：
   - **数据来源**：效果读取的数据从哪里来？（已有状态 vs 额外随机、当前状态 vs 快照）
   - **计算方式**：数值如何计算？（动态计算 vs 固定值）
   - **作用目标**：效果作用于谁？（自身 vs 对手）
   - **作用目标语义边界（强制）**：描述中每个名词的语义边界必须精确锁定。**无限定词 = 不区分**，有限定词 = 严格过滤。禁止凭"游戏常识"自行添加描述中不存在的限定条件。

3. **代码语义验证**：逐个检查实现代码是否与描述语义一致

4. **测试语义验证**：检查测试是否按正确语义编写。**测试通过但语义错误 = 测试本身有 bug**，必须同时修复实现和测试

### 上下文角色反转场景（强制）

> 某些执行上下文会交换角色身份（如防御阶段中"攻击者"实际指防御者）。

**审查方法**：
1. grep 所有涉及角色反转上下文的 handler，逐个验证角色字段使用是否与约定一致
2. 验证测试构建的上下文是否与运行时约定一致
3. **测试必须断言关键事件的目标 ID**（伤害打到谁、buff 给谁），不能只断言数量和数值

---

## 测试覆盖要求（强制）

- **新增功能必须补充测试**：覆盖正常+异常场景
- **GameTestRunner 优先**：行为测试是最可靠的测试手段
- **契约测试补充**：批量覆盖注册表引用完整性和交互链完整性
- **端到端测试**：关键交互面必须有 E2E 覆盖

---
