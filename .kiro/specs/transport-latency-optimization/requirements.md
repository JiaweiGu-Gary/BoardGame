# 需求文档：传输层延迟优化

## 简介

当前在线模式下，每次用户交互（点击骰子、选择单位、选择卡牌）都需要通过 WebSocket 发送命令到服务端，等待服务端执行 `executePipeline` 后广播完整状态，客户端才能更新 UI。这导致了明显的网络延迟感。本特性通过三个引擎层优化策略（乐观更新、本地交互状态、命令批处理）来降低在线模式的感知延迟，同时保持状态一致性和动画系统的正确性。

## 术语表

- **Pipeline**：`executePipeline` 函数，接收当前状态和命令，返回新状态的纯函数
- **GameProvider**：在线模式的 React 上下文提供者，通过 WebSocket 与服务端通信
- **LocalGameProvider**：本地模式的 React 上下文提供者，在客户端直接执行 Pipeline
- **EventStreamSystem**：事件流系统，记录可消费的事件序列，用于驱动动画和音效
- **InteractionSystem**：交互系统，管理玩家选择（simple-choice、slider-choice）
- **乐观状态（Optimistic_State）**：客户端本地预测执行 Pipeline 后产生的临时状态
- **确认状态（Confirmed_State）**：服务端执行 Pipeline 后广播的权威状态
- **命令批次（Command_Batch）**：在时间窗口内收集的多个命令合并为一次网络请求
- **确定性命令（Deterministic_Command）**：不依赖服务端随机数的命令，客户端可安全预测
- **非确定性命令（Non_Deterministic_Command）**：依赖服务端随机数的命令（如掷骰子、洗牌），客户端无法预测结果
- **本地交互状态（Local_Interaction_State）**：多步交互过程中仅在客户端维护的中间状态，最终提交时才发送网络命令
- **回滚（Rollback）**：当服务端确认状态与乐观状态不一致时，将客户端状态恢复为确认状态的过程

## 需求

### 需求 1：乐观更新框架

**用户故事：** 作为在线模式的玩家，我希望点击操作后 UI 立即响应，而不是等待服务端返回，以获得接近本地模式的流畅体验。

#### 验收标准

1. WHEN 玩家在在线模式下发送一个确定性命令, THE GameProvider SHALL 在客户端本地执行 Pipeline 生成乐观状态并立即更新 UI，同时将命令发送到服务端
2. WHEN 服务端返回确认状态, THE GameProvider SHALL 用确认状态替换当前乐观状态
3. WHEN 服务端返回的确认状态与乐观状态不一致, THE GameProvider SHALL 执行回滚，将 UI 状态恢复为确认状态
4. WHEN 玩家发送一个非确定性命令（如掷骰子）, THE GameProvider SHALL 跳过本地预测，仅发送命令到服务端并等待确认状态
5. WHILE 存在未确认的乐观状态, THE GameProvider SHALL 将后续命令基于乐观状态进行本地预测，并在服务端确认后按序校验
6. IF 客户端本地 Pipeline 执行失败（验证不通过）, THEN THE GameProvider SHALL 不更新乐观状态，仅将命令发送到服务端等待权威结果
7. WHEN 乐观更新产生事件流, THE EventStreamSystem SHALL 仅在服务端确认状态到达后触发动画和音效，乐观状态产生的事件流不触发动画

### 需求 2：游戏命令确定性声明

**用户故事：** 作为游戏开发者，我希望能够声明哪些命令是确定性的，以便引擎自动决定是否启用乐观更新。

#### 验收标准

1. THE 引擎层 SHALL 提供命令确定性声明接口，允许游戏在 Domain 配置中标注每个命令是否为确定性命令
2. WHEN 游戏未声明命令的确定性属性, THE 引擎层 SHALL 默认将该命令视为非确定性命令（保守策略）
3. THE 确定性声明 SHALL 支持静态声明（命令类型级别）和动态判断（基于当前状态和 payload 的运行时判断）


### 需求 3：本地交互状态管理

**用户故事：** 作为在线模式的玩家，我希望多步交互（如逐个锁定骰子、多选卡牌）在本地即时响应，只在最终确认时才发送网络请求。

#### 验收标准

1. THE 引擎层 SHALL 提供本地交互状态管理机制，允许游戏将多步交互的中间状态维护在客户端
2. WHEN 玩家在本地交互过程中执行中间步骤（如锁定一个骰子）, THE 本地交互管理器 SHALL 立即更新本地 UI 状态，不发送网络命令
3. WHEN 玩家确认本地交互的最终结果（如确认掷骰选择）, THE 本地交互管理器 SHALL 将最终结果作为单个命令发送到服务端
4. WHEN 玩家在本地交互过程中取消操作, THE 本地交互管理器 SHALL 恢复到交互开始前的本地状态，不发送任何网络命令
5. IF 服务端返回的确认状态与本地交互最终提交的预期不一致, THEN THE 本地交互管理器 SHALL 以服务端状态为准进行回滚
6. THE 本地交互状态管理 SHALL 通过引擎层通用机制实现，游戏层通过配置声明哪些命令属于本地交互的中间步骤

### 需求 4：命令批处理

**用户故事：** 作为在线模式的玩家，我希望快速连续的操作（如连续选择多个骰子重掷）被合并为一次网络请求，减少网络往返次数。

#### 验收标准

1. THE 引擎层 SHALL 提供命令批处理机制，在可配置的时间窗口内收集多个命令合并为一次网络请求
2. WHEN 多个命令在批处理时间窗口内被发送, THE 命令批处理器 SHALL 将这些命令合并为一个命令批次发送到服务端
3. WHEN 服务端收到命令批次, THE GameTransportServer SHALL 按顺序依次执行批次中的每个命令，保持串行执行保证
4. IF 命令批次中某个命令执行失败, THEN THE GameTransportServer SHALL 停止执行后续命令，将已执行的状态广播给客户端，并返回失败命令的错误信息
5. THE 命令批处理 SHALL 支持游戏层配置批处理时间窗口大小和最大批次命令数
6. WHEN 批处理时间窗口为 0 或未配置, THE 命令批处理器 SHALL 退化为逐条发送模式

### 需求 5：配置驱动的渐进式启用

**用户故事：** 作为游戏开发者，我希望通过 Domain 配置声明来启用延迟优化策略，引擎层自动处理所有优化逻辑。

#### 验收标准

1. THE 引擎层 SHALL 允许游戏通过 Domain 配置独立启用乐观更新、本地交互状态、命令批处理三个优化策略的任意组合
2. WHEN 乐观更新被启用, THE GameProvider SHALL 在客户端持有与服务端相同的 Pipeline 配置（domain、systems、systemsConfig），以确保本地预测的准确性
3. THE 所有优化策略 SHALL 通过引擎层通用接口实现，游戏层仅需提供配置声明，无需修改 Board 组件或 resolveMoves 逻辑

### 需求 6：状态一致性保障

**用户故事：** 作为系统架构师，我希望在所有优化策略下，服务端状态始终是权威的，客户端最终一致。

#### 验收标准

1. THE GameTransportServer SHALL 保持为唯一的状态权威来源，所有客户端最终收敛到服务端状态
2. WHEN 乐观状态与确认状态发生冲突, THE GameProvider SHALL 在回滚时保留确认状态产生的 EventStream 事件，丢弃乐观状态产生的事件
3. WHILE 客户端处于乐观状态, THE GameProvider SHALL 维护一个未确认命令队列，记录每个乐观命令的类型、payload 和预测状态
4. WHEN 服务端确认一个命令, THE GameProvider SHALL 从未确认命令队列中移除该命令，并将队列中剩余命令基于新的确认状态重新预测
5. IF 网络断开后重连, THEN THE GameProvider SHALL 丢弃所有乐观状态，以服务端同步的完整状态为准重新开始
